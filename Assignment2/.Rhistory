formals(sum)
log(exp(1))
e = exp(1)
log(e)
log(4,2)
log(0,2)
log(-1)
log(2) + log(4)
log(8)
log(8) == log(2) + log(4)
log(4)
log(2)
2*log(2)
log(2,4)
a <- matrix(1:4,2,2)
solve(a)
solve(a) %*% a
b = 3
b = 4
b = 5
summary(mean)
str(mean)
list(1,"a")
a <- list(1,"a")
str(a)
str(str)
str(lm)
m <- matrix(1:100 , 10 , 10)
str(m)
summary(m)
m <- matrix(1:100 , 5 , 20)
summary(m)
library(datasets)
rpois(exp(1))
rpois(1,exp(1))
rpois(2,exp(1))
exp(1)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(2,2)
rpois(1,exp(1))
rpois(1,exp(1))
rpois(1,exp(1))
rpois(1,exp(1))
rpois(1,exp(1))
rpois(1,exp(1))
rpois(1,exp(1))
rpois(1,exp(1))
dnorm(2)
dnorm(3)
dnorm(4)
dnorm(10)
dnorm(0)
dnorm(-2)
pnorm(10)
pnorm(5)
set.seed(1)
rnorm(5)
rnorm(5)
set.seed(1)
rnorm(5)
rnorm(5)
set.seed(!)
set.seed(1)
rnorm(5)
rpois(5,2)
set.seed(1)
rnorm(5)
rpois(5,2)
set.seed(10)
x< - rnorm(100)
x <- rnorm(100)
e <- rnorm(100,2)
e <- rnorm(100 , 0 , 2 )
y  <- 0.5 + 2*x + e
plot(x,y)
plot(x,y)
plot(x,y)
plot(x,y)
plot(x,y)
rbinom(100 , 1 , 0.7)
log.mu <- 5
mu
exp(log.mu)
Always set the seed
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10 , 4)
sample(1:10)
sample(1:10)
sample(1:10)
sample(1:10)
system.time(log(10))
square(3)
system.time(readline("http://www.google.com"))
str(system.time)
?system.time
proc.time
proc.time()
proc.time()
proc.time()
proc.time()
proc.time()
proc.time()
proc.time()
proc.time()
a = 2
a
print a
print"a"
print(a)
install.packages("gbm")
install.packages("gbm")
install.packages("gbm")
swirl()
swirl
?mean
2:3
a <- data.frame(1:3,c(NA,4,NA),c(4,5,6))
a
ind<- which(is.na(a),arr.ind = TRUE)
a[ind] <- rowmeans(df , na.rm = TRUE)[ind[,1]]
a[ind] <- rowMeans(df , na.rm = TRUE)[ind[,1]]
a[ind] <- rowMeans(a , na.rm = TRUE)[ind[,1]]
a
a[1,3] <- NA
a[1,1] <- NA
a[ind] <- rowMeans(a , na.rm = TRUE)[ind[,1]]
a
ind<- which(is.na(a),arr.ind = TRUE)
a[ind] <- rowMeans(a , na.rm = TRUE)[ind[,1]]
a
a <- data.frame(1:3,c(NA,4,NA),c(4,5,6))
a
a[2,2] <- NA
a[3,2] <- 5
a[1,2] <- 1
a[2,2] <- 3
unlist([1 2 3])
unlist([1 ,  2  ,3])
unlist(c(1,2,3))
c(1,2,3)
unlist?
unlist(c(1,2,c(3,4)))
c(1,2,c(3,4))
help(unlist)
unlist(c(1,c(2,3),c(3,4)))
c(1,c(2,3),c(3,4))
a = c(1,c(2,3),c(3,4))
l1 <- list(a = "a", b = 2, c = pi+2i)
l1
unlist(l1)
1+2i * 2
(1+2i )* (2 + 3i)
"a" + "b"
"a"."b"
"a""b"
paste("a" , "b")
paste("apple" , "mango")
paste("apple" , "mango" , sep=NULL)
paste("apple" , "mango" , sep = "")
q()
swirl
swirl()
library("swirl")
swirl()
5+7
x <- 5 + 7
x
y <- x - 3
y
c( 'x' , 1)
z <- c(1.1 , 9 , 3.14)
?c
z
c(z,555,z)
z*2 + 100
my_sqrt = sqrt(z-1)
my_sqrt <- sqrt(z-1)
my_sqrt
my_div = z/my_sqrt
my_div <-  z/my_sqrt
my_div
c(1 , 2 , 3 , 4) + c(0 , 10)
c(1,2,3,4) + c(0,10, 100)
z*2 + 1000
my_div
1:20
pi:10
15:1
?':'
seq(1,20)
seq(0,10 , by = 0.5)
seq(5,10, length = 30 )
my_seq = seq(5,10,length=30)
my_seq <- seq(5,10,length=30)
length(my_seq)
1:length(my_seq)
seq(along = my_seq)
seq_along(my_seq)
rep(0 , times = 40 )
rep(c(0, 1, 2), times = 10)
rep(c(0,1,2) , each = 10)
c(0.5 , 55 , -10 , 6)
num_vect <- c(0.5 , 55 , -10 , 6)
tf <- num_vect < 1
tf
num_vect >= 6
my_char <- c("My" , "name" , "is")
my_char
paster(my_char , colapse = " ")
paste(my_char , colapse = " ")
paste(my_char)
paste(my_char , collapse = " ")
c(my_char , "Ayush")
my_name <- c(my_char , "Ayush")
my_name
paste(my_name , collapse = " ")
paste("Hello" , "world!" , sep = " ")
paste(1:3 , c('X' ,'Y' ,'Z'))
paste(1:3 , c('X' ,'Y' ,'Z') , sep="")
paste(LETTERS, 1:4, sep = "-")
library("swirl")
swirl()
quit()
sample(0:1,1)
sample(0:1,1)
sample(0:1,1)
sample(0:1,1)
sample just takes a sample from the data
library(UsingR)
install.packages("UsingR")
data(father.son)
qnorm(0.975)
qnorm?
q(0)
?qnorm
pnorm(1)
pnorm(-1)
qnorm(0.95)
qnorm(0.95)*75 + 1100
qnorm(0.95)*7.5 + 1100
1/32(6)
6/32
qnorm(-1)
pnorm(-1)
rpois
pois
ppois(10,5)
ppois(10,15)
getCVerrorNoBagging <- function(n , Data_size) {
flds <- createFolds(1:length(mydata[[1]]), k = 5, list = TRUE, returnTrain = FALSE)
error_sum = 0
for (i in 1:5){
test = mydata[flds[[i]] , ]
train = mydata[-flds[[i]] ,  ]
rows = length(train[[1]])
forest <- randomForest(V1 ~. , data = train , xtest = test[,c(2:17)] , ytest = test[,1],  ntree = n, sampsize = 160*Data_size) #Bagging Done and 4 attributes used
error_sum = error_sum + 1 - (sum(diag(forest$test$confusion))/length(test[[1]]))
}
return(error_sum/5) #5 fold cross validation
}
getCVerrorNoBagging <- function(n , Data_size) {
flds <- createFolds(1:length(mydata[[1]]), k = 5, list = TRUE, returnTrain = FALSE)
error_sum = 0
for (i in 1:5){
test = mydata[flds[[i]] , ]
train = mydata[-flds[[i]] ,  ]
rows = length(train[[1]])
forest <- randomForest(V1 ~. , data = train , xtest = test[,c(2:17)] , ytest = test[,1],  ntree = n, sampsize = 160*Data_size, mtry = 16) #Bagging Done and 4 attributes used
error_sum = error_sum + 1 - (sum(diag(forest$test$confusion))/length(test[[1]]))
}
return(error_sum/5) #5 fold cross validation
}
getCutoffTreeNumber <- function(Data_size) {
start = 2
end = 450
min_error = getCVerrorNoBagging(end , Data_size )
repeat {
mid = round((start + end)/2)
mid_error = getCVerrorNoBagging(mid , Data_size)
if(mid == start || mid == end)
break
if((0.045*min_error <= (mid_error - min_error)) && ((mid_error - min_error) <= 0.05*min_error))
break
#Mid is the point of interest
#Iterate till you get to optimal range
if((mid_error - min_error) > 0.05*min_error)
start = mid
if((mid_error - min_error) < 0.045*min_error)
end = mid
}
return(c(mid , mid_error))
}
getCutoffTreeNumber(100)
source("parta.R")
setwd('/Users/ayusek/Desktop/Academics/MLT/MLT-Machine-Learning-Techniques-CS771-IITK/Assignment2') #Need to be changed accordingly
source("parta.R")
mydata
getCVerrorNoBagging <- function(n , Data_size) {
flds <- createFolds(1:length(mydata[[1]]), k = 5, list = TRUE, returnTrain = FALSE)
error_sum = 0
for (i in 1:5){
test = mydata[flds[[i]] , ]
train = mydata[-flds[[i]] ,  ]
rows = length(train[[1]])
forest <- randomForest(V1 ~. , data = train , xtest = test[,c(2:17)] , ytest = test[,1],  ntree = n, sampsize = 160*Data_size, mtry = 16) #Bagging Done and 4 attributes used
error_sum = error_sum + 1 - (sum(diag(forest$test$confusion))/length(test[[1]]))
}
return(error_sum/5) #5 fold cross validation
}
getCutoffTreeNumber <- function(Data_size) {
start = 2
end = 450
min_error = getCVerrorNoBagging(end , Data_size )
repeat {
mid = round((start + end)/2)
mid_error = getCVerrorNoBagging(mid , Data_size)
if(mid == start || mid == end)
break
if((0.045*min_error <= (mid_error - min_error)) && ((mid_error - min_error) <= 0.05*min_error))
break
#Mid is the point of interest
#Iterate till you get to optimal range
if((mid_error - min_error) > 0.05*min_error)
start = mid
if((mid_error - min_error) < 0.045*min_error)
end = mid
}
return(c(mid , mid_error))
}
getCutoffTreeNumber(100)
getCutoffTreeNumber(100)
